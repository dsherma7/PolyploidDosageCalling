
#' Linear Regression on PCR Variables
#'
#' Uses a regression technique to model log(Dosage) as a function of delta CT values.
#' @param Results.Only FALSE means that the AllData is actually a three-dimensonal list with the third dimension being each sheet in the data sets. If AllData only contains the "Results' section then set this to TRUE.
#' @param Controls data.frame containing the Control values for this experiment. Must have column names of Actual.Name, Name, Dosage; where Actual.Name is what is found exactly in the data sets, Name is the desired output name (often the same as Actual.Name), and Dosage is the Dosage for each control.
#' @param Index The range of the rows to be used in the fit of the AllData data frame.
#' @param AllData A serial data frame of all the relevant values including Job, Plate, RQ, CT, delta CT, and Sample Name.
GetDosage <- function(AllData, index = 1:length(AllData), Controls = NULL, Target='Assay1'){
  library(plyr)
  MeanRQ <- 
      mean(unlist(
        lapply(AllData,function(each.job){
          lapply(each.job,function(each.plate){
            mean(as.numeric(each.plate$RQ),na.rm=T)
          })})),na.rm=T)
  
  
  Dosages <- data.frame()
  for (each.job in index){
    Job <- data.frame()
    Plates <- names(AllData[[each.job]])
    for(each.plate in 1:length(Plates)){
      tryCatch({
        plate <- GetDosageForSinglePlate(Plate=AllData[[each.job]][[each.plate]], job=names(AllData)[each.job], plate=Plates[each.plate], Controls=Controls, MeanRQ=MeanRQ, Target=Target)
        Job <- rbind.fill(Job, plate)
      },error = function(e){
        print(paste0('Plate ',Plates[each.plate],' returned the error: ',e))
        Job <- NULL;
      })
    }
    Dosages <- rbind(Dosages,Job);
  }
  names(Dosages) <- names(Job)
  return(Dosages)
}

#' Linear Model on a Single Plate
#'
#' This function performs a linear fit of log2(Dosage) as a function of delta CT for a single plate.
#' It also computes a Multinomial distribution of Dosage ~ f(P(RQ)) where P is a 2nd degree polynomial.
#' @param MeanRQ The Mean RQ value across all Jobs/Plates. Used for scaling the data to provide a more balanced dosage call. Default=NULL means no scaling.
#' @param Controls data.frame containing the Control values for this experiment. Must have column names of Actual.Name, Name, Dosage; where Actual.Name is what is found exactly in the data sets, Name is the desired output name (often the same as Actual.Name), and Dosage is the Dosage for each control.
#' @param plate Name of the plate.
#' @param job Name of the job that this plate is under.
#' @param Plate A serial data frame of all the relevant values including Job, Plate, RQ, CT, delta CT, and Sample Name for a single plate.
GetDosageForSinglePlate <- function(Plate, job=NA, plate=NA, Controls=NULL, MeanRQ=NULL, Target='Assay1'){
  if (is.null(Controls)){
    warning("No Control Variables Provided, Operation Stopped Before Completion.")
    return(NA)
  }
  # Scale each plate to minimize batch effects and ease cross-comparison
  if (is.null(MeanRQ)){
    MeanRQ = mean(as.numeric(Plate$RQ),na.rm = TRUE)
  }
  Plate$RQ <- (MeanRQ/mean(as.numeric(Plate$RQ),na.rm = TRUE))*as.numeric(Plate$RQ);
  
  library(gdata)
  Job <- Plate[which(Plate$Target.Name==Target),];
  PEF <- Plate[which(Plate$Target.Name!=Target),];
  Job$CT <- as.double(Job$CT)
  Job$dCT <- as.double(Job$Delta.Ct)
  Job$CT.PEF <- as.double(PEF$CT)
  Job$QS.RQ <- as.double(Job$RQ)
  Job$QS.Dosage <- round(Job$QS.RQ)
  Job$Multinom <- Job$Dosage <- NA
  Job$Job <- job
  
  # Multinomial Log-Linear Neural Network
  tryCatch({
      Job$Controls <- Controls$Dosage[match(Job$`Clone-plant_ID`,Controls$Name)]
      library(nnet)
      # Fits a neural network using linear and non-linear features generated by RQ, CT, and dCT
      fit <- multinom(Controls~log2(QS.RQ)+CT+CT.PEF+dCT+QS.Dosage+CT^2+QS.RQ^2,data = Job,Hess = TRUE,maxit = 10000,model=TRUE,abstol = 1.0e-10,reltol=1.0e-12,quiet = TRUE,trace = FALSE)
      Job$Multinom <- as.integer(predict(fit,Job))
    },
  error = function(e){
      print(paste0('Multinomial Model on plate ',plate,' Returned the Error: ',e))
    })
  
  # Throw a warning if there is more than 5% of samples with significantly off results.
  if ((length(which(Job$Multinom > 4)) + length(which(Job$Multinom < 0))) > 0.05*length(Job$Multinom)){
      Job$Multinom <- NA;
      warning(paste("Multinomial Fit Method Produced Wild Results for",plate,"Check Control Values."))
    }
  Job$Dosage[which(Job$Multinom < 0)] <- 0
  Job$Dosage[which(Job$Multinom > 4)] <- 4
    
  # Use a standard Linear Model to fit log2(Dosage) ~ log2(RQ), which should follow a linear trend. 
  tryCatch({
      Names <- intersect(Controls$Name,unique(Job$`Clone-plant_ID`))
      Vals <- Controls[!duplicated(Controls$Name),]$Dosage[which(Controls$Name[!duplicated(Controls$Name)] %in% unique(Job$`Clone-plant_ID`))]
      ByControls <- lapply(Names, function(x){Job[which(Job$`Clone-plant_ID` == x),]})
      names(ByControls) <- Names
      Deltas <- data.frame( dCT =  sapply(ByControls,function(x){mean(as.double(x$dCT),na.rm = TRUE)}), Dosage = Vals)
      Curve <- data.frame(x = unique(Deltas$Dosage)[!is.na(unique(Deltas$Dosage))],y = sapply(sort(unique(Deltas$Dosage)),function(x){mean(Deltas$dCT[which(Deltas$Dosage == x)],na.rm = TRUE)}))
      
      if (sum(!is.na(Curve$y),na.rm = TRUE) > 0){
        fit <- lm(log2(Curve$y + abs(min(Job$dCT,na.rm = TRUE)))~Curve$x)
        f <- function(dct){1/(fit$coefficients[2])*(log2(dct+abs(min(Job$dCT,na.rm = TRUE)))-fit$coefficients[1])}
        Job$Dosage <- round(f(Job$dCT))
      }else{
        Job$Dosage <- "Undetermined";
      }
    },
  error = function(e){ 
      print(paste0('Linear Model on plate ',plate,' Returned the Error: ',e))
    })
  
  # Throw a warning if there is more than 5% of samples with significantly off results.
  if ((length(which(Job$Dosage > 4)) + length(which(Job$Dosage < 0))) > 0.05*length(Job$Dosage)){
      Job$Dosage <- NA
      warning(paste("Linear Fit Method Produced Wild Results for",plate,"Check Control Values."))
    }
  Job$Dosage[which(Job$Dosage < 0)] <- 0
  Job$Dosage[which(Job$Dosage > 4)] <- 4
    
  
  return(Job)
}
